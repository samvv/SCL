
import type { List, Range } from "./interfaces.js";
import { CursorBase, RangeBase } from "./util.js";

export class DLNode<T> extends CursorBase<T> {

  constructor(public value: T, public _prevNode: DLNode<T> | null = null, public _nextNode: DLNode<T> | null = null) {
    super();
  }

  public next(): DLNode<T> | null {
    return this._nextNode;
  }

  public prev(): DLNode<T> | null {
    return this._prevNode;
  }

}

export class DoubleLinkedListRange<T> extends RangeBase<T> {

  constructor(protected _startNode: DLNode<T> | null, protected _endNode: DLNode<T> | null, public readonly reversed: boolean) {
    super();
  }

  public *[Symbol.iterator](): IterableIterator<T> {
    for (const cursor of this.cursors()) {
      yield cursor.value;
    }
  }

  public *cursors(): IterableIterator<DoubleLinkedListCursor<T>> {
    let node = this._startNode;
    while (node !== null) {
      yield node;
      if (node === this._endNode) {
        break;
      }
      node = this.reversed ? node._prevNode : node._nextNode;
    }
  }

  public reverse(): Range<T> {
    return new DoubleLinkedListRange(this._endNode, this._startNode, !this.reversed);
  }

  get size(): number {
    let count = 0;
    let node = this._startNode;
    while (node !== null) {
      count++;
      if (node === this._endNode) {
        break;
      }
      node = node._nextNode;
    }
    return count;
  }

}

export type DoubleLinkedListCursor<T> = DLNode<T>;

/**
 * A doubly-linked list, which is sometimes faster than a singly-linked list
 * but consumes a bit more memory.
 *
 * ```ts
 * import { DoubleLinkedList } from "scl"
 * ```
 *
 * The following table summarises the time complexity of the most commonly used
 * properties.
 *
 * | Property name                                        | Worst-case |
 * |------------------------------------------------------|------------|
 * | {@link DoubleLinkedList.append append()}             | O(1)       |
 * | {@link DoubleLinkedList.at at()}                     | O(n)       |
 * | {@link DoubleLinkedList.insertAfter insertAfter()}   | O(1)       |
 * | {@link DoubleLinkedList.insertBefore insertBefore()} | O(1)       |
 * | {@link DoubleLinkedList.deleteAt deleteAt()}         | O(1)       |
 * | {@link DoubleLinkedList.prepend prepend()}           | O(1)       |
 * | {@link DoubleLinkedList.size size}                   | O(1)       |
 *
 * @see [[SingleLinkedList]]
 *
 * @typeparam T The type of element in this collection.
 */
export class DoubleLinkedList<T> implements List<T> {

  public get size(): number {
    return this._size;
  }

 /**
  * Will create a doubly-linked list filled with the elements generated by the
  * given iterable.
  */
  public static from<T>(iterable: Iterable<T>): DoubleLinkedList<T> {
    const list = new DoubleLinkedList<T>();
    for (const element of iterable) {
      list.append(element);
    }
    return list;
  }

  public static empty<T>(): DoubleLinkedList<T> {
    return new DoubleLinkedList<T>();
  }

  /**
   * @ignore
   */
  public _firstNode: DLNode<T> | null = null;

  /**
   * @ignore
   */
  public _lastNode: DLNode<T> | null = null;

  /**
   * @ignore
   */
  public _size = 0;

  /**
   * Creates a singly-linked list, optionally filled with the elements
   * generated by the given iterable.
   *
   * ```ts
   * const l = new DoubleinkedList();
   * ```
   *
   * You can also construct a linked list from any iterable, like so:
   *
   * ```ts
   * const l = new DoubleLinkedList([1, 2, 3])
   * ```
   */
  constructor(iterable?: Iterable<T>) {
    if (iterable !== undefined) {
      for (const element of iterable) {
        this.append(element);
      }
    }
  }

  public insertBefore(pos: DLNode<T>, el: T): DoubleLinkedListCursor<T> {
    if (pos._prevNode === null) {
      return this.prepend(el);
    } else {
      const newNode = new DLNode(el, pos._prevNode, pos);
      pos._prevNode._nextNode = newNode;
      pos._prevNode = newNode;
      ++this._size;
      return newNode;
    }
  }

  public first(): T {
    if (this._firstNode === null) {
      throw new Error(`Cannot get first element: collection is empty.`);
    }
    return this._firstNode.value;
  }

  public last(): T {
    if (this._lastNode === null) {
      throw new Error(`Cannot get last element: collection is empty.`);
    }
    return this._lastNode.value;
  }

  public add(element: T): [boolean, DoubleLinkedListCursor<T>] {
    return [true, this.append(element)];
  }

  public insertAfter(pos: DLNode<T>, el: T): DoubleLinkedListCursor<T> {
    if (pos._nextNode === null) {
      return this.append(el);
    } else {
      const newNode = new DLNode<T>(el, pos, pos._nextNode);
      pos._nextNode._prevNode = newNode;
      pos._nextNode = newNode;
      ++this._size;
      return newNode;
    }
  }

  public prepend(el: T): DoubleLinkedListCursor<T> {
    const newNode = new DLNode<T>(el, null, this._firstNode);
    this._firstNode = newNode;
    if (this._lastNode === null) {
      this._lastNode = newNode;
    }
    ++this._size;
    return newNode;
  }

  public append(el: T): DoubleLinkedListCursor<T> {
    const newNode = new DLNode<T>(el, this._lastNode, null);
    if (this._firstNode === null) {
      this._firstNode = newNode;
    } else {
      this._lastNode!._nextNode = newNode;
    }
    this._lastNode = newNode;
    ++this._size;
    return newNode;
  }

  public has(el: T): boolean {
    let node = this._firstNode;
    while (node !== null) {
      if (node.value === el) {
        return true;
      }
      node = node._nextNode;
    }
    return false;
  }

  public *[Symbol.iterator](): IterableIterator<T> {
    let node = this._firstNode;
    while (node !== null) {
      yield node.value;
      node = node._nextNode;
    }
  }

  public toRange(): DoubleLinkedListRange<T> {
    return new DoubleLinkedListRange<T>(this._firstNode, this._lastNode, false);
  }

  public at(position: number): DoubleLinkedListCursor<T> {
    let node = this._firstNode!;
    while (position > 0) {
      node = node._nextNode!;
      if (node === null) {
        throw new RangeError(`Cannot get element at position ${position}: index out of bounds.`);
      }
      --position;
    }
    return node;
  }

  public getAt(position: number): T {
    return this.at(position).value;
  }

  public deleteAt(position: DLNode<T>): void {
    if (position._prevNode !== null) {
      position._prevNode._nextNode = position._nextNode;
    }
    if (position._nextNode !== null) {
      position._nextNode._prevNode = position._prevNode;
    }
    --this._size;
    if (position === this._firstNode) {
      this._firstNode = position._nextNode;
    }
    if (position === this._lastNode) {
      this._lastNode = position._prevNode;
    }
  }

  public delete(el: T): boolean {
    let node = this._firstNode;
    while (node !== null) {
      if (node.value === el) {
        this.deleteAt(node);
        return true;
      }
      node = node._nextNode;
    }
    return false;
  }

  public deleteAll(el: T): number {
    let count = 0;
    let node = this._firstNode;
    while (node !== null) {
      if (node.value === el) {
        this.deleteAt(node);
        count++;
      }
      node = node._nextNode;
    }
    return count;
  }

  public rest(): List<T> {
    if (this._firstNode === null) {
      throw new Error(`Cannot get rest of list: collection is empty`);
    }
    const list = new DoubleLinkedList<T>();
    list._firstNode = this._firstNode._nextNode;
    list._lastNode = this._lastNode;
    list._size = this._size - 1;
    return list;
  }

  public clear(): void {
    this._firstNode = null;
    this._lastNode = null;
    this._size = 0;
  }

 public clone(): DoubleLinkedList<T> {
   return new DoubleLinkedList<T>(this);
 }

}

export default DoubleLinkedList;
